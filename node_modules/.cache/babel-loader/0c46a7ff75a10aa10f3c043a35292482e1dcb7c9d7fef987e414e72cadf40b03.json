{"ast":null,"code":"// src/infiniteQueryBehavior.ts\nimport { addToEnd, addToStart, skipToken } from \"./utils.js\";\nfunction infiniteQueryBehavior(pages) {\n  return {\n    onFetch: (context, query) => {\n      const fetchFn = async () => {\n        var _context$fetchOptions, _context$state$data, _context$state$data2;\n        const options = context.options;\n        const direction = (_context$fetchOptions = context.fetchOptions) === null || _context$fetchOptions === void 0 || (_context$fetchOptions = _context$fetchOptions.meta) === null || _context$fetchOptions === void 0 || (_context$fetchOptions = _context$fetchOptions.fetchMore) === null || _context$fetchOptions === void 0 ? void 0 : _context$fetchOptions.direction;\n        const oldPages = ((_context$state$data = context.state.data) === null || _context$state$data === void 0 ? void 0 : _context$state$data.pages) || [];\n        const oldPageParams = ((_context$state$data2 = context.state.data) === null || _context$state$data2 === void 0 ? void 0 : _context$state$data2.pageParams) || [];\n        const empty = {\n          pages: [],\n          pageParams: []\n        };\n        let cancelled = false;\n        const addSignalProperty = object => {\n          Object.defineProperty(object, \"signal\", {\n            enumerable: true,\n            get: () => {\n              if (context.signal.aborted) {\n                cancelled = true;\n              } else {\n                context.signal.addEventListener(\"abort\", () => {\n                  cancelled = true;\n                });\n              }\n              return context.signal;\n            }\n          });\n        };\n        const queryFn = context.options.queryFn && context.options.queryFn !== skipToken ? context.options.queryFn : () => {\n          if (process.env.NODE_ENV !== \"production\") {\n            if (context.options.queryFn === skipToken) {\n              console.error(\"Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '\".concat(context.options.queryHash, \"'\"));\n            }\n          }\n          return Promise.reject(new Error(\"Missing queryFn: '\".concat(context.options.queryHash, \"'\")));\n        };\n        const fetchPage = async (data, param, previous) => {\n          if (cancelled) {\n            return Promise.reject();\n          }\n          if (param == null && data.pages.length) {\n            return Promise.resolve(data);\n          }\n          const queryFnContext = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            direction: previous ? \"backward\" : \"forward\",\n            meta: context.options.meta\n          };\n          addSignalProperty(queryFnContext);\n          const page = await queryFn(queryFnContext);\n          const {\n            maxPages\n          } = context.options;\n          const addTo = previous ? addToStart : addToEnd;\n          return {\n            pages: addTo(data.pages, page, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages)\n          };\n        };\n        let result;\n        if (direction && oldPages.length) {\n          const previous = direction === \"backward\";\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;\n          const oldData = {\n            pages: oldPages,\n            pageParams: oldPageParams\n          };\n          const param = pageParamFn(options, oldData);\n          result = await fetchPage(oldData, param, previous);\n        } else {\n          var _oldPageParams$;\n          result = await fetchPage(empty, (_oldPageParams$ = oldPageParams[0]) !== null && _oldPageParams$ !== void 0 ? _oldPageParams$ : options.initialPageParam);\n          const remainingPages = pages !== null && pages !== void 0 ? pages : oldPages.length;\n          for (let i = 1; i < remainingPages; i++) {\n            const param = getNextPageParam(options, result);\n            result = await fetchPage(result, param);\n          }\n        }\n        return result;\n      };\n      if (context.options.persister) {\n        context.fetchFn = () => {\n          var _context$options$pers, _context$options;\n          return (_context$options$pers = (_context$options = context.options).persister) === null || _context$options$pers === void 0 ? void 0 : _context$options$pers.call(_context$options, fetchFn, {\n            queryKey: context.queryKey,\n            meta: context.options.meta,\n            signal: context.signal\n          }, query);\n        };\n      } else {\n        context.fetchFn = fetchFn;\n      }\n    }\n  };\n}\nfunction getNextPageParam(options, _ref) {\n  let {\n    pages,\n    pageParams\n  } = _ref;\n  const lastIndex = pages.length - 1;\n  return options.getNextPageParam(pages[lastIndex], pages, pageParams[lastIndex], pageParams);\n}\nfunction getPreviousPageParam(options, _ref2) {\n  var _options$getPreviousP;\n  let {\n    pages,\n    pageParams\n  } = _ref2;\n  return (_options$getPreviousP = options.getPreviousPageParam) === null || _options$getPreviousP === void 0 ? void 0 : _options$getPreviousP.call(options, pages[0], pages, pageParams[0], pageParams);\n}\nfunction hasNextPage(options, data) {\n  if (!data) return false;\n  return getNextPageParam(options, data) != null;\n}\nfunction hasPreviousPage(options, data) {\n  if (!data || !options.getPreviousPageParam) return false;\n  return getPreviousPageParam(options, data) != null;\n}\nexport { hasNextPage, hasPreviousPage, infiniteQueryBehavior };","map":{"version":3,"names":["addToEnd","addToStart","skipToken","infiniteQueryBehavior","pages","onFetch","context","query","fetchFn","_context$fetchOptions","_context$state$data","_context$state$data2","options","direction","fetchOptions","meta","fetchMore","oldPages","state","data","oldPageParams","pageParams","empty","cancelled","addSignalProperty","object","Object","defineProperty","enumerable","get","signal","aborted","addEventListener","queryFn","process","env","NODE_ENV","console","error","concat","queryHash","Promise","reject","Error","fetchPage","param","previous","length","resolve","queryFnContext","queryKey","pageParam","page","maxPages","addTo","result","pageParamFn","getPreviousPageParam","getNextPageParam","oldData","_oldPageParams$","initialPageParam","remainingPages","i","persister","_context$options$pers","_context$options","call","_ref","lastIndex","_ref2","_options$getPreviousP","hasNextPage","hasPreviousPage"],"sources":["/Users/zohankhan/Downloads/zohan-test/node_modules/@tanstack/query-core/src/infiniteQueryBehavior.ts"],"sourcesContent":["import { addToEnd, addToStart, skipToken } from './utils'\nimport type { QueryBehavior } from './query'\nimport type {\n  InfiniteData,\n  InfiniteQueryPageParamsOptions,\n  OmitKeyof,\n  QueryFunctionContext,\n  QueryKey,\n} from './types'\n\nexport function infiniteQueryBehavior<TQueryFnData, TError, TData, TPageParam>(\n  pages?: number,\n): QueryBehavior<TQueryFnData, TError, InfiniteData<TData, TPageParam>> {\n  return {\n    onFetch: (context, query) => {\n      const fetchFn = async () => {\n        const options = context.options as InfiniteQueryPageParamsOptions<TData>\n        const direction = context.fetchOptions?.meta?.fetchMore?.direction\n        const oldPages = context.state.data?.pages || []\n        const oldPageParams = context.state.data?.pageParams || []\n        const empty = { pages: [], pageParams: [] }\n        let cancelled = false\n\n        const addSignalProperty = (object: unknown) => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              if (context.signal.aborted) {\n                cancelled = true\n              } else {\n                context.signal.addEventListener('abort', () => {\n                  cancelled = true\n                })\n              }\n              return context.signal\n            },\n          })\n        }\n\n        // Get query function\n        const queryFn =\n          context.options.queryFn && context.options.queryFn !== skipToken\n            ? context.options.queryFn\n            : () => {\n                if (process.env.NODE_ENV !== 'production') {\n                  if (context.options.queryFn === skipToken) {\n                    console.error(\n                      `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${context.options.queryHash}'`,\n                    )\n                  }\n                }\n                return Promise.reject(\n                  new Error(`Missing queryFn: '${context.options.queryHash}'`),\n                )\n              }\n\n        // Create function to fetch a page\n        const fetchPage = async (\n          data: InfiniteData<unknown>,\n          param: unknown,\n          previous?: boolean,\n        ): Promise<InfiniteData<unknown>> => {\n          if (cancelled) {\n            return Promise.reject()\n          }\n\n          if (param == null && data.pages.length) {\n            return Promise.resolve(data)\n          }\n\n          const queryFnContext: OmitKeyof<\n            QueryFunctionContext<QueryKey, unknown>,\n            'signal'\n          > = {\n            queryKey: context.queryKey,\n            pageParam: param,\n            direction: previous ? 'backward' : 'forward',\n            meta: context.options.meta,\n          }\n\n          addSignalProperty(queryFnContext)\n\n          const page = await queryFn(\n            queryFnContext as QueryFunctionContext<QueryKey, unknown>,\n          )\n\n          const { maxPages } = context.options\n          const addTo = previous ? addToStart : addToEnd\n\n          return {\n            pages: addTo(data.pages, page, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages),\n          }\n        }\n\n        let result: InfiniteData<unknown>\n\n        // fetch next / previous page?\n        if (direction && oldPages.length) {\n          const previous = direction === 'backward'\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam\n          const oldData = {\n            pages: oldPages,\n            pageParams: oldPageParams,\n          }\n          const param = pageParamFn(options, oldData)\n\n          result = await fetchPage(oldData, param, previous)\n        } else {\n          // Fetch first page\n          result = await fetchPage(\n            empty,\n            oldPageParams[0] ?? options.initialPageParam,\n          )\n\n          const remainingPages = pages ?? oldPages.length\n\n          // Fetch remaining pages\n          for (let i = 1; i < remainingPages; i++) {\n            const param = getNextPageParam(options, result)\n            result = await fetchPage(result, param)\n          }\n        }\n\n        return result\n      }\n      if (context.options.persister) {\n        context.fetchFn = () => {\n          return context.options.persister?.(\n            fetchFn as any,\n            {\n              queryKey: context.queryKey,\n              meta: context.options.meta,\n              signal: context.signal,\n            },\n            query,\n          )\n        }\n      } else {\n        context.fetchFn = fetchFn\n      }\n    },\n  }\n}\n\nfunction getNextPageParam(\n  options: InfiniteQueryPageParamsOptions<any>,\n  { pages, pageParams }: InfiniteData<unknown>,\n): unknown | undefined {\n  const lastIndex = pages.length - 1\n  return options.getNextPageParam(\n    pages[lastIndex],\n    pages,\n    pageParams[lastIndex],\n    pageParams,\n  )\n}\n\nfunction getPreviousPageParam(\n  options: InfiniteQueryPageParamsOptions<any>,\n  { pages, pageParams }: InfiniteData<unknown>,\n): unknown | undefined {\n  return options.getPreviousPageParam?.(\n    pages[0],\n    pages,\n    pageParams[0],\n    pageParams,\n  )\n}\n\n/**\n * Checks if there is a next page.\n */\nexport function hasNextPage(\n  options: InfiniteQueryPageParamsOptions<any, any>,\n  data?: InfiniteData<unknown>,\n): boolean {\n  if (!data) return false\n  return getNextPageParam(options, data) != null\n}\n\n/**\n * Checks if there is a previous page.\n */\nexport function hasPreviousPage(\n  options: InfiniteQueryPageParamsOptions<any, any>,\n  data?: InfiniteData<unknown>,\n): boolean {\n  if (!data || !options.getPreviousPageParam) return false\n  return getPreviousPageParam(options, data) != null\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}