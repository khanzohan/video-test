{"ast":null,"code":"import _classPrivateFieldInitSpec from \"/Users/zohankhan/Downloads/zohan-test/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateFieldGet from \"/Users/zohankhan/Downloads/zohan-test/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _classPrivateFieldSet from \"/Users/zohankhan/Downloads/zohan-test/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\nvar _mutations, _mutationId;\n// src/mutationCache.ts\nimport { notifyManager } from \"./notifyManager.js\";\nimport { Mutation } from \"./mutation.js\";\nimport { matchMutation, noop } from \"./utils.js\";\nimport { Subscribable } from \"./subscribable.js\";\nvar MutationCache = (_mutations = /*#__PURE__*/new WeakMap(), _mutationId = /*#__PURE__*/new WeakMap(), class MutationCache extends Subscribable {\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    _classPrivateFieldInitSpec(this, _mutations, void 0);\n    _classPrivateFieldInitSpec(this, _mutationId, void 0);\n    this.config = config;\n    _classPrivateFieldSet(_mutations, this, /* @__PURE__ */new Map());\n    _classPrivateFieldSet(_mutationId, this, Date.now());\n  }\n  build(client, options, state) {\n    var _this$mutationId;\n    const mutation = new Mutation({\n      mutationCache: this,\n      mutationId: _classPrivateFieldSet(_mutationId, this, (_this$mutationId = _classPrivateFieldGet(_mutationId, this), ++_this$mutationId)),\n      options: client.defaultMutationOptions(options),\n      state\n    });\n    this.add(mutation);\n    return mutation;\n  }\n  add(mutation) {\n    var _classPrivateFieldGet2;\n    const scope = scopeFor(mutation);\n    const mutations = (_classPrivateFieldGet2 = _classPrivateFieldGet(_mutations, this).get(scope)) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : [];\n    mutations.push(mutation);\n    _classPrivateFieldGet(_mutations, this).set(scope, mutations);\n    this.notify({\n      type: \"added\",\n      mutation\n    });\n  }\n  remove(mutation) {\n    const scope = scopeFor(mutation);\n    if (_classPrivateFieldGet(_mutations, this).has(scope)) {\n      var _classPrivateFieldGet3;\n      const mutations = (_classPrivateFieldGet3 = _classPrivateFieldGet(_mutations, this).get(scope)) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3.filter(x => x !== mutation);\n      if (mutations) {\n        if (mutations.length === 0) {\n          _classPrivateFieldGet(_mutations, this).delete(scope);\n        } else {\n          _classPrivateFieldGet(_mutations, this).set(scope, mutations);\n        }\n      }\n    }\n    this.notify({\n      type: \"removed\",\n      mutation\n    });\n  }\n  canRun(mutation) {\n    var _classPrivateFieldGet4;\n    const firstPendingMutation = (_classPrivateFieldGet4 = _classPrivateFieldGet(_mutations, this).get(scopeFor(mutation))) === null || _classPrivateFieldGet4 === void 0 ? void 0 : _classPrivateFieldGet4.find(m => m.state.status === \"pending\");\n    return !firstPendingMutation || firstPendingMutation === mutation;\n  }\n  runNext(mutation) {\n    var _classPrivateFieldGet5, _foundMutation$contin;\n    const foundMutation = (_classPrivateFieldGet5 = _classPrivateFieldGet(_mutations, this).get(scopeFor(mutation))) === null || _classPrivateFieldGet5 === void 0 ? void 0 : _classPrivateFieldGet5.find(m => m !== mutation && m.state.isPaused);\n    return (_foundMutation$contin = foundMutation === null || foundMutation === void 0 ? void 0 : foundMutation.continue()) !== null && _foundMutation$contin !== void 0 ? _foundMutation$contin : Promise.resolve();\n  }\n  clear() {\n    notifyManager.batch(() => {\n      this.getAll().forEach(mutation => {\n        this.remove(mutation);\n      });\n    });\n  }\n  getAll() {\n    return [..._classPrivateFieldGet(_mutations, this).values()].flat();\n  }\n  find(filters) {\n    const defaultedFilters = {\n      exact: true,\n      ...filters\n    };\n    return this.getAll().find(mutation => matchMutation(defaultedFilters, mutation));\n  }\n  findAll() {\n    let filters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.getAll().filter(mutation => matchMutation(filters, mutation));\n  }\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(event);\n      });\n    });\n  }\n  resumePausedMutations() {\n    const pausedMutations = this.getAll().filter(x => x.state.isPaused);\n    return notifyManager.batch(() => Promise.all(pausedMutations.map(mutation => mutation.continue().catch(noop))));\n  }\n});\nfunction scopeFor(mutation) {\n  var _mutation$options$sco, _mutation$options$sco2;\n  return (_mutation$options$sco = (_mutation$options$sco2 = mutation.options.scope) === null || _mutation$options$sco2 === void 0 ? void 0 : _mutation$options$sco2.id) !== null && _mutation$options$sco !== void 0 ? _mutation$options$sco : String(mutation.mutationId);\n}\nexport { MutationCache };","map":{"version":3,"names":["notifyManager","Mutation","matchMutation","noop","Subscribable","MutationCache","_mutations","WeakMap","_mutationId","constructor","config","arguments","length","undefined","_classPrivateFieldInitSpec","_classPrivateFieldSet","Map","Date","now","build","client","options","state","_this$mutationId","mutation","mutationCache","mutationId","_classPrivateFieldGet","defaultMutationOptions","add","_classPrivateFieldGet2","scope","scopeFor","mutations","get","push","set","notify","type","remove","has","_classPrivateFieldGet3","filter","x","delete","canRun","_classPrivateFieldGet4","firstPendingMutation","find","m","status","runNext","_classPrivateFieldGet5","_foundMutation$contin","foundMutation","isPaused","continue","Promise","resolve","clear","batch","getAll","forEach","values","flat","filters","defaultedFilters","exact","findAll","event","listeners","listener","resumePausedMutations","pausedMutations","all","map","catch","_mutation$options$sco","_mutation$options$sco2","id","String"],"sources":["/Users/zohankhan/Downloads/zohan-test/node_modules/@tanstack/query-core/src/mutationCache.ts"],"sourcesContent":["import { notifyManager } from './notifyManager'\nimport { Mutation } from './mutation'\nimport { matchMutation, noop } from './utils'\nimport { Subscribable } from './subscribable'\nimport type { MutationObserver } from './mutationObserver'\nimport type { DefaultError, MutationOptions, NotifyEvent } from './types'\nimport type { QueryClient } from './queryClient'\nimport type { Action, MutationState } from './mutation'\nimport type { MutationFilters } from './utils'\n\n// TYPES\n\ninterface MutationCacheConfig {\n  onError?: (\n    error: DefaultError,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSuccess?: (\n    data: unknown,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onMutate?: (\n    variables: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSettled?: (\n    data: unknown | undefined,\n    error: DefaultError | null,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n}\n\ninterface NotifyEventMutationAdded extends NotifyEvent {\n  type: 'added'\n  mutation: Mutation<any, any, any, any>\n}\ninterface NotifyEventMutationRemoved extends NotifyEvent {\n  type: 'removed'\n  mutation: Mutation<any, any, any, any>\n}\n\ninterface NotifyEventMutationObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  mutation?: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any, any>\n}\n\ninterface NotifyEventMutationUpdated extends NotifyEvent {\n  type: 'updated'\n  mutation: Mutation<any, any, any, any>\n  action: Action<any, any, any, any>\n}\n\nexport type MutationCacheNotifyEvent =\n  | NotifyEventMutationAdded\n  | NotifyEventMutationRemoved\n  | NotifyEventMutationObserverAdded\n  | NotifyEventMutationObserverRemoved\n  | NotifyEventMutationObserverOptionsUpdated\n  | NotifyEventMutationUpdated\n\ntype MutationCacheListener = (event: MutationCacheNotifyEvent) => void\n\n// CLASS\n\nexport class MutationCache extends Subscribable<MutationCacheListener> {\n  #mutations: Map<string, Array<Mutation<any, any, any, any>>>\n  #mutationId: number\n\n  constructor(public config: MutationCacheConfig = {}) {\n    super()\n    this.#mutations = new Map()\n    this.#mutationId = Date.now()\n  }\n\n  build<TData, TError, TVariables, TContext>(\n    client: QueryClient,\n    options: MutationOptions<TData, TError, TVariables, TContext>,\n    state?: MutationState<TData, TError, TVariables, TContext>,\n  ): Mutation<TData, TError, TVariables, TContext> {\n    const mutation = new Mutation({\n      mutationCache: this,\n      mutationId: ++this.#mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n    })\n\n    this.add(mutation)\n\n    return mutation\n  }\n\n  add(mutation: Mutation<any, any, any, any>): void {\n    const scope = scopeFor(mutation)\n    const mutations = this.#mutations.get(scope) ?? []\n    mutations.push(mutation)\n    this.#mutations.set(scope, mutations)\n    this.notify({ type: 'added', mutation })\n  }\n\n  remove(mutation: Mutation<any, any, any, any>): void {\n    const scope = scopeFor(mutation)\n    if (this.#mutations.has(scope)) {\n      const mutations = this.#mutations\n        .get(scope)\n        ?.filter((x) => x !== mutation)\n      if (mutations) {\n        if (mutations.length === 0) {\n          this.#mutations.delete(scope)\n        } else {\n          this.#mutations.set(scope, mutations)\n        }\n      }\n    }\n\n    this.notify({ type: 'removed', mutation })\n  }\n\n  canRun(mutation: Mutation<any, any, any, any>): boolean {\n    const firstPendingMutation = this.#mutations\n      .get(scopeFor(mutation))\n      ?.find((m) => m.state.status === 'pending')\n\n    // we can run if there is no current pending mutation (start use-case)\n    // or if WE are the first pending mutation (continue use-case)\n    return !firstPendingMutation || firstPendingMutation === mutation\n  }\n\n  runNext(mutation: Mutation<any, any, any, any>): Promise<unknown> {\n    const foundMutation = this.#mutations\n      .get(scopeFor(mutation))\n      ?.find((m) => m !== mutation && m.state.isPaused)\n\n    return foundMutation?.continue() ?? Promise.resolve()\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((mutation) => {\n        this.remove(mutation)\n      })\n    })\n  }\n\n  getAll(): Array<Mutation> {\n    return [...this.#mutations.values()].flat()\n  }\n\n  find<\n    TData = unknown,\n    TError = DefaultError,\n    TVariables = any,\n    TContext = unknown,\n  >(\n    filters: MutationFilters,\n  ): Mutation<TData, TError, TVariables, TContext> | undefined {\n    const defaultedFilters = { exact: true, ...filters }\n\n    return this.getAll().find((mutation) =>\n      matchMutation(defaultedFilters, mutation),\n    ) as Mutation<TData, TError, TVariables, TContext> | undefined\n  }\n\n  findAll(filters: MutationFilters = {}): Array<Mutation> {\n    return this.getAll().filter((mutation) => matchMutation(filters, mutation))\n  }\n\n  notify(event: MutationCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event)\n      })\n    })\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    const pausedMutations = this.getAll().filter((x) => x.state.isPaused)\n\n    return notifyManager.batch(() =>\n      Promise.all(\n        pausedMutations.map((mutation) => mutation.continue().catch(noop)),\n      ),\n    )\n  }\n}\n\nfunction scopeFor(mutation: Mutation<any, any, any, any>) {\n  return mutation.options.scope?.id ?? String(mutation.mutationId)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}