{"ast":null,"code":"import _classPrivateMethodInitSpec from \"/Users/zohankhan/Downloads/zohan-test/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"/Users/zohankhan/Downloads/zohan-test/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _assertClassBrand from \"/Users/zohankhan/Downloads/zohan-test/node_modules/@babel/runtime/helpers/esm/assertClassBrand.js\";\nimport _classPrivateFieldGet from \"/Users/zohankhan/Downloads/zohan-test/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _classPrivateFieldSet from \"/Users/zohankhan/Downloads/zohan-test/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\nvar _initialState, _revertState, _cache, _retryer, _defaultOptions, _abortSignalConsumed, _Class_brand;\n// src/query.ts\nimport { noop, replaceData, skipToken, timeUntilStale } from \"./utils.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { canFetch, createRetryer, isCancelledError } from \"./retryer.js\";\nimport { Removable } from \"./removable.js\";\nvar Query = (_initialState = /*#__PURE__*/new WeakMap(), _revertState = /*#__PURE__*/new WeakMap(), _cache = /*#__PURE__*/new WeakMap(), _retryer = /*#__PURE__*/new WeakMap(), _defaultOptions = /*#__PURE__*/new WeakMap(), _abortSignalConsumed = /*#__PURE__*/new WeakMap(), _Class_brand = /*#__PURE__*/new WeakSet(), class Query extends Removable {\n  constructor(config) {\n    super();\n    _classPrivateMethodInitSpec(this, _Class_brand);\n    _classPrivateFieldInitSpec(this, _initialState, void 0);\n    _classPrivateFieldInitSpec(this, _revertState, void 0);\n    _classPrivateFieldInitSpec(this, _cache, void 0);\n    _classPrivateFieldInitSpec(this, _retryer, void 0);\n    _classPrivateFieldInitSpec(this, _defaultOptions, void 0);\n    _classPrivateFieldInitSpec(this, _abortSignalConsumed, void 0);\n    _classPrivateFieldSet(_abortSignalConsumed, this, false);\n    _classPrivateFieldSet(_defaultOptions, this, config.defaultOptions);\n    this.setOptions(config.options);\n    this.observers = [];\n    _classPrivateFieldSet(_cache, this, config.cache);\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    _classPrivateFieldSet(_initialState, this, config.state || getDefaultState(this.options));\n    this.state = _classPrivateFieldGet(_initialState, this);\n    this.scheduleGc();\n  }\n  get meta() {\n    return this.options.meta;\n  }\n  setOptions(options) {\n    this.options = {\n      ..._classPrivateFieldGet(_defaultOptions, this),\n      ...options\n    };\n    this.updateGcTime(this.options.gcTime);\n  }\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === \"idle\") {\n      _classPrivateFieldGet(_cache, this).remove(this);\n    }\n  }\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options);\n    _assertClassBrand(_Class_brand, this, _dispatch).call(this, {\n      data,\n      type: \"success\",\n      dataUpdatedAt: options === null || options === void 0 ? void 0 : options.updatedAt,\n      manual: options === null || options === void 0 ? void 0 : options.manual\n    });\n    return data;\n  }\n  setState(state, setStateOptions) {\n    _assertClassBrand(_Class_brand, this, _dispatch).call(this, {\n      type: \"setState\",\n      state,\n      setStateOptions\n    });\n  }\n  cancel(options) {\n    var _classPrivateFieldGet2, _classPrivateFieldGet3;\n    const promise = (_classPrivateFieldGet2 = _classPrivateFieldGet(_retryer, this)) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.promise;\n    (_classPrivateFieldGet3 = _classPrivateFieldGet(_retryer, this)) === null || _classPrivateFieldGet3 === void 0 || _classPrivateFieldGet3.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n  destroy() {\n    super.destroy();\n    this.cancel({\n      silent: true\n    });\n  }\n  reset() {\n    this.destroy();\n    this.setState(_classPrivateFieldGet(_initialState, this));\n  }\n  isActive() {\n    return this.observers.some(observer => observer.options.enabled !== false);\n  }\n  isDisabled() {\n    return this.getObserversCount() > 0 && !this.isActive();\n  }\n  isStale() {\n    if (this.state.isInvalidated) {\n      return true;\n    }\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(observer => observer.getCurrentResult().isStale);\n    }\n    return this.state.data === void 0;\n  }\n  isStaleByTime() {\n    let staleTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return this.state.isInvalidated || this.state.data === void 0 || !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n  onFocus() {\n    var _classPrivateFieldGet4;\n    const observer = this.observers.find(x => x.shouldFetchOnWindowFocus());\n    observer === null || observer === void 0 || observer.refetch({\n      cancelRefetch: false\n    });\n    (_classPrivateFieldGet4 = _classPrivateFieldGet(_retryer, this)) === null || _classPrivateFieldGet4 === void 0 || _classPrivateFieldGet4.continue();\n  }\n  onOnline() {\n    var _classPrivateFieldGet5;\n    const observer = this.observers.find(x => x.shouldFetchOnReconnect());\n    observer === null || observer === void 0 || observer.refetch({\n      cancelRefetch: false\n    });\n    (_classPrivateFieldGet5 = _classPrivateFieldGet(_retryer, this)) === null || _classPrivateFieldGet5 === void 0 || _classPrivateFieldGet5.continue();\n  }\n  addObserver(observer) {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer);\n      this.clearGcTimeout();\n      _classPrivateFieldGet(_cache, this).notify({\n        type: \"observerAdded\",\n        query: this,\n        observer\n      });\n    }\n  }\n  removeObserver(observer) {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter(x => x !== observer);\n      if (!this.observers.length) {\n        if (_classPrivateFieldGet(_retryer, this)) {\n          if (_classPrivateFieldGet(_abortSignalConsumed, this)) {\n            _classPrivateFieldGet(_retryer, this).cancel({\n              revert: true\n            });\n          } else {\n            _classPrivateFieldGet(_retryer, this).cancelRetry();\n          }\n        }\n        this.scheduleGc();\n      }\n      _classPrivateFieldGet(_cache, this).notify({\n        type: \"observerRemoved\",\n        query: this,\n        observer\n      });\n    }\n  }\n  getObserversCount() {\n    return this.observers.length;\n  }\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      _assertClassBrand(_Class_brand, this, _dispatch).call(this, {\n        type: \"invalidate\"\n      });\n    }\n  }\n  fetch(options, fetchOptions) {\n    var _this$options$behavio, _context$fetchOptions;\n    if (this.state.fetchStatus !== \"idle\") {\n      if (this.state.data !== void 0 && fetchOptions !== null && fetchOptions !== void 0 && fetchOptions.cancelRefetch) {\n        this.cancel({\n          silent: true\n        });\n      } else if (_classPrivateFieldGet(_retryer, this)) {\n        _classPrivateFieldGet(_retryer, this).continueRetry();\n        return _classPrivateFieldGet(_retryer, this).promise;\n      }\n    }\n    if (options) {\n      this.setOptions(options);\n    }\n    if (!this.options.queryFn) {\n      const observer = this.observers.find(x => x.options.queryFn);\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\"As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']\");\n      }\n    }\n    const abortController = new AbortController();\n    const queryFnContext = {\n      queryKey: this.queryKey,\n      meta: this.meta\n    };\n    const addSignalProperty = object => {\n      Object.defineProperty(object, \"signal\", {\n        enumerable: true,\n        get: () => {\n          _classPrivateFieldSet(_abortSignalConsumed, this, true);\n          return abortController.signal;\n        }\n      });\n    };\n    addSignalProperty(queryFnContext);\n    const fetchFn = () => {\n      if (process.env.NODE_ENV !== \"production\") {\n        if (this.options.queryFn === skipToken) {\n          console.error(\"Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '\".concat(this.options.queryHash, \"'\"));\n        }\n      }\n      if (!this.options.queryFn || this.options.queryFn === skipToken) {\n        return Promise.reject(new Error(\"Missing queryFn: '\".concat(this.options.queryHash, \"'\")));\n      }\n      _classPrivateFieldSet(_abortSignalConsumed, this, false);\n      if (this.options.persister) {\n        return this.options.persister(this.options.queryFn, queryFnContext, this);\n      }\n      return this.options.queryFn(queryFnContext);\n    };\n    const context = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn\n    };\n    addSignalProperty(context);\n    (_this$options$behavio = this.options.behavior) === null || _this$options$behavio === void 0 || _this$options$behavio.onFetch(context, this);\n    _classPrivateFieldSet(_revertState, this, this.state);\n    if (this.state.fetchStatus === \"idle\" || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) === null || _context$fetchOptions === void 0 ? void 0 : _context$fetchOptions.meta)) {\n      var _context$fetchOptions2;\n      _assertClassBrand(_Class_brand, this, _dispatch).call(this, {\n        type: \"fetch\",\n        meta: (_context$fetchOptions2 = context.fetchOptions) === null || _context$fetchOptions2 === void 0 ? void 0 : _context$fetchOptions2.meta\n      });\n    }\n    const onError = error => {\n      if (!(isCancelledError(error) && error.silent)) {\n        _assertClassBrand(_Class_brand, this, _dispatch).call(this, {\n          type: \"error\",\n          error\n        });\n      }\n      if (!isCancelledError(error)) {\n        var _classPrivateFieldGet6, _classPrivateFieldGet7, _classPrivateFieldGet8, _classPrivateFieldGet9;\n        (_classPrivateFieldGet6 = (_classPrivateFieldGet7 = _classPrivateFieldGet(_cache, this).config).onError) === null || _classPrivateFieldGet6 === void 0 || _classPrivateFieldGet6.call(_classPrivateFieldGet7, error, this);\n        (_classPrivateFieldGet8 = (_classPrivateFieldGet9 = _classPrivateFieldGet(_cache, this).config).onSettled) === null || _classPrivateFieldGet8 === void 0 || _classPrivateFieldGet8.call(_classPrivateFieldGet9, this.state.data, error, this);\n      }\n      if (!this.isFetchingOptimistic) {\n        this.scheduleGc();\n      }\n      this.isFetchingOptimistic = false;\n    };\n    _classPrivateFieldSet(_retryer, this, createRetryer({\n      fn: context.fetchFn,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: data => {\n        var _classPrivateFieldGet10, _classPrivateFieldGet11, _classPrivateFieldGet12, _classPrivateFieldGet13;\n        if (data === void 0) {\n          if (process.env.NODE_ENV !== \"production\") {\n            console.error(\"Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: \".concat(this.queryHash));\n          }\n          onError(new Error(\"\".concat(this.queryHash, \" data is undefined\")));\n          return;\n        }\n        this.setData(data);\n        (_classPrivateFieldGet10 = (_classPrivateFieldGet11 = _classPrivateFieldGet(_cache, this).config).onSuccess) === null || _classPrivateFieldGet10 === void 0 || _classPrivateFieldGet10.call(_classPrivateFieldGet11, data, this);\n        (_classPrivateFieldGet12 = (_classPrivateFieldGet13 = _classPrivateFieldGet(_cache, this).config).onSettled) === null || _classPrivateFieldGet12 === void 0 || _classPrivateFieldGet12.call(_classPrivateFieldGet13, data, this.state.error, this);\n        if (!this.isFetchingOptimistic) {\n          this.scheduleGc();\n        }\n        this.isFetchingOptimistic = false;\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        _assertClassBrand(_Class_brand, this, _dispatch).call(this, {\n          type: \"failed\",\n          failureCount,\n          error\n        });\n      },\n      onPause: () => {\n        _assertClassBrand(_Class_brand, this, _dispatch).call(this, {\n          type: \"pause\"\n        });\n      },\n      onContinue: () => {\n        _assertClassBrand(_Class_brand, this, _dispatch).call(this, {\n          type: \"continue\"\n        });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n      canRun: () => true\n    }));\n    return _classPrivateFieldGet(_retryer, this).start();\n  }\n});\nfunction _dispatch(action) {\n  const reducer = state => {\n    var _action$meta, _action$dataUpdatedAt;\n    switch (action.type) {\n      case \"failed\":\n        return {\n          ...state,\n          fetchFailureCount: action.failureCount,\n          fetchFailureReason: action.error\n        };\n      case \"pause\":\n        return {\n          ...state,\n          fetchStatus: \"paused\"\n        };\n      case \"continue\":\n        return {\n          ...state,\n          fetchStatus: \"fetching\"\n        };\n      case \"fetch\":\n        return {\n          ...state,\n          ...fetchState(state.data, this.options),\n          fetchMeta: (_action$meta = action.meta) !== null && _action$meta !== void 0 ? _action$meta : null\n        };\n      case \"success\":\n        return {\n          ...state,\n          data: action.data,\n          dataUpdateCount: state.dataUpdateCount + 1,\n          dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) !== null && _action$dataUpdatedAt !== void 0 ? _action$dataUpdatedAt : Date.now(),\n          error: null,\n          isInvalidated: false,\n          status: \"success\",\n          ...(!action.manual && {\n            fetchStatus: \"idle\",\n            fetchFailureCount: 0,\n            fetchFailureReason: null\n          })\n        };\n      case \"error\":\n        const error = action.error;\n        if (isCancelledError(error) && error.revert && _classPrivateFieldGet(_revertState, this)) {\n          return {\n            ..._classPrivateFieldGet(_revertState, this),\n            fetchStatus: \"idle\"\n          };\n        }\n        return {\n          ...state,\n          error,\n          errorUpdateCount: state.errorUpdateCount + 1,\n          errorUpdatedAt: Date.now(),\n          fetchFailureCount: state.fetchFailureCount + 1,\n          fetchFailureReason: error,\n          fetchStatus: \"idle\",\n          status: \"error\"\n        };\n      case \"invalidate\":\n        return {\n          ...state,\n          isInvalidated: true\n        };\n      case \"setState\":\n        return {\n          ...state,\n          ...action.state\n        };\n    }\n  };\n  this.state = reducer(this.state);\n  notifyManager.batch(() => {\n    this.observers.forEach(observer => {\n      observer.onQueryUpdate();\n    });\n    _classPrivateFieldGet(_cache, this).notify({\n      query: this,\n      type: \"updated\",\n      action\n    });\n  });\n}\nfunction fetchState(data, options) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: canFetch(options.networkMode) ? \"fetching\" : \"paused\",\n    ...(data === void 0 && {\n      error: null,\n      status: \"pending\"\n    })\n  };\n}\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === \"function\" ? options.initialData() : options.initialData;\n  const hasData = data !== void 0;\n  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === \"function\" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt !== null && initialDataUpdatedAt !== void 0 ? initialDataUpdatedAt : Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? \"success\" : \"pending\",\n    fetchStatus: \"idle\"\n  };\n}\nexport { Query, fetchState };","map":{"version":3,"names":["noop","replaceData","skipToken","timeUntilStale","notifyManager","canFetch","createRetryer","isCancelledError","Removable","Query","_initialState","WeakMap","_revertState","_cache","_retryer","_defaultOptions","_abortSignalConsumed","_Class_brand","WeakSet","constructor","config","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","_classPrivateFieldSet","defaultOptions","setOptions","options","observers","cache","queryKey","queryHash","state","getDefaultState","_classPrivateFieldGet","scheduleGc","meta","updateGcTime","gcTime","optionalRemove","length","fetchStatus","remove","setData","newData","data","_assertClassBrand","_dispatch","call","type","dataUpdatedAt","updatedAt","manual","setState","setStateOptions","cancel","_classPrivateFieldGet2","_classPrivateFieldGet3","promise","then","catch","Promise","resolve","destroy","silent","reset","isActive","some","observer","enabled","isDisabled","getObserversCount","isStale","isInvalidated","getCurrentResult","isStaleByTime","staleTime","arguments","undefined","onFocus","_classPrivateFieldGet4","find","x","shouldFetchOnWindowFocus","refetch","cancelRefetch","continue","onOnline","_classPrivateFieldGet5","shouldFetchOnReconnect","addObserver","includes","push","clearGcTimeout","notify","query","removeObserver","filter","revert","cancelRetry","invalidate","fetch","fetchOptions","_this$options$behavio","_context$fetchOptions","continueRetry","queryFn","process","env","NODE_ENV","Array","isArray","console","error","abortController","AbortController","queryFnContext","addSignalProperty","object","Object","defineProperty","enumerable","get","signal","fetchFn","concat","reject","Error","persister","context","behavior","onFetch","fetchMeta","_context$fetchOptions2","onError","_classPrivateFieldGet6","_classPrivateFieldGet7","_classPrivateFieldGet8","_classPrivateFieldGet9","onSettled","isFetchingOptimistic","fn","abort","bind","onSuccess","_classPrivateFieldGet10","_classPrivateFieldGet11","_classPrivateFieldGet12","_classPrivateFieldGet13","onFail","failureCount","onPause","onContinue","retry","retryDelay","networkMode","canRun","start","action","reducer","_action$meta","_action$dataUpdatedAt","fetchFailureCount","fetchFailureReason","fetchState","dataUpdateCount","Date","now","status","errorUpdateCount","errorUpdatedAt","batch","forEach","onQueryUpdate","initialData","hasData","initialDataUpdatedAt"],"sources":["/Users/zohankhan/Downloads/zohan-test/node_modules/@tanstack/query-core/src/query.ts"],"sourcesContent":["import { noop, replaceData, skipToken, timeUntilStale } from './utils'\nimport { notifyManager } from './notifyManager'\nimport { canFetch, createRetryer, isCancelledError } from './retryer'\nimport { Removable } from './removable'\nimport type {\n  CancelOptions,\n  DefaultError,\n  FetchStatus,\n  InitialDataFunction,\n  OmitKeyof,\n  QueryFunctionContext,\n  QueryKey,\n  QueryMeta,\n  QueryOptions,\n  QueryStatus,\n  SetDataOptions,\n} from './types'\nimport type { QueryCache } from './queryCache'\nimport type { QueryObserver } from './queryObserver'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface QueryConfig<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  cache: QueryCache\n  queryKey: TQueryKey\n  queryHash: string\n  options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = DefaultError> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchFailureReason: TError | null\n  fetchMeta: FetchMeta | null\n  isInvalidated: boolean\n  status: QueryStatus\n  fetchStatus: FetchStatus\n}\n\nexport interface FetchContext<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  signal: AbortSignal\n  options: QueryOptions<TQueryFnData, TError, TData, any>\n  queryKey: TQueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  onFetch: (\n    context: FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n    query: Query,\n  ) => void\n}\n\nexport type FetchDirection = 'forward' | 'backward'\n\nexport interface FetchMeta {\n  fetchMore?: { direction: FetchDirection }\n}\n\nexport interface FetchOptions {\n  cancelRefetch?: boolean\n  meta?: FetchMeta\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: FetchMeta\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n  manual?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: Partial<QueryState<TData, TError>>\n  setStateOptions?: SetStateOptions\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\nexport interface SetStateOptions {\n  meta?: any\n}\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Removable {\n  queryKey: TQueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state: QueryState<TData, TError>\n  isFetchingOptimistic?: boolean\n\n  #initialState: QueryState<TData, TError>\n  #revertState?: QueryState<TData, TError>\n  #cache: QueryCache\n  #retryer?: Retryer<TData>\n  observers: Array<QueryObserver<any, any, any, any, any>>\n  #defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  #abortSignalConsumed: boolean\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>) {\n    super()\n\n    this.#abortSignalConsumed = false\n    this.#defaultOptions = config.defaultOptions\n    this.setOptions(config.options)\n    this.observers = []\n    this.#cache = config.cache\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.#initialState = config.state || getDefaultState(this.options)\n    this.state = this.#initialState\n    this.scheduleGc()\n  }\n  get meta(): QueryMeta | undefined {\n    return this.options.meta\n  }\n\n  setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): void {\n    this.options = { ...this.#defaultOptions, ...options }\n\n    this.updateGcTime(this.options.gcTime)\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.#cache.remove(this)\n    }\n  }\n\n  setData(\n    newData: TData,\n    options?: SetDataOptions & { manual: boolean },\n  ): TData {\n    const data = replaceData(this.state.data, newData, this.options)\n\n    // Set data and mark it as cached\n    this.#dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual,\n    })\n\n    return data\n  }\n\n  setState(\n    state: Partial<QueryState<TData, TError>>,\n    setStateOptions?: SetStateOptions,\n  ): void {\n    this.#dispatch({ type: 'setState', state, setStateOptions })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.#retryer?.promise\n    this.#retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    super.destroy()\n\n    this.cancel({ silent: true })\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.#initialState)\n  }\n\n  isActive(): boolean {\n    return this.observers.some((observer) => observer.options.enabled !== false)\n  }\n\n  isDisabled(): boolean {\n    return this.getObserversCount() > 0 && !this.isActive()\n  }\n\n  isStale(): boolean {\n    if (this.state.isInvalidated) {\n      return true\n    }\n\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) => observer.getCurrentResult().isStale,\n      )\n    }\n\n    return this.state.data === undefined\n  }\n\n  isStaleByTime(staleTime = 0): boolean {\n    return (\n      this.state.isInvalidated ||\n      this.state.data === undefined ||\n      !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n    )\n  }\n\n  onFocus(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.#cache.notify({ type: 'observerAdded', query: this, observer })\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter((x) => x !== observer)\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true })\n          } else {\n            this.#retryer.cancelRetry()\n          }\n        }\n\n        this.scheduleGc()\n      }\n\n      this.#cache.notify({ type: 'observerRemoved', query: this, observer })\n    }\n  }\n\n  getObserversCount(): number {\n    return this.observers.length\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: 'invalidate' })\n    }\n  }\n\n  fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    fetchOptions?: FetchOptions,\n  ): Promise<TData> {\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.data !== undefined && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetch\n        this.cancel({ silent: true })\n      } else if (this.#retryer) {\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        this.#retryer.continueRetry()\n        // Return current promise if we are already fetching\n        return this.#retryer.promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn)\n      if (observer) {\n        this.setOptions(observer.options)\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`,\n        )\n      }\n    }\n\n    const abortController = new AbortController()\n\n    // Create query function context\n    const queryFnContext: OmitKeyof<\n      QueryFunctionContext<TQueryKey>,\n      'signal'\n    > = {\n      queryKey: this.queryKey,\n      meta: this.meta,\n    }\n\n    // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n    const addSignalProperty = (object: unknown) => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true\n          return abortController.signal\n        },\n      })\n    }\n\n    addSignalProperty(queryFnContext)\n\n    // Create fetch function\n    const fetchFn = () => {\n      if (process.env.NODE_ENV !== 'production') {\n        if (this.options.queryFn === skipToken) {\n          console.error(\n            `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${this.options.queryHash}'`,\n          )\n        }\n      }\n\n      if (!this.options.queryFn || this.options.queryFn === skipToken) {\n        return Promise.reject(\n          new Error(`Missing queryFn: '${this.options.queryHash}'`),\n        )\n      }\n\n      this.#abortSignalConsumed = false\n      if (this.options.persister) {\n        return this.options.persister(\n          this.options.queryFn,\n          queryFnContext as QueryFunctionContext<TQueryKey>,\n          this as unknown as Query,\n        )\n      }\n\n      return this.options.queryFn(\n        queryFnContext as QueryFunctionContext<TQueryKey>,\n      )\n    }\n\n    // Trigger behavior hook\n    const context: OmitKeyof<\n      FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n      'signal'\n    > = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn,\n    }\n\n    addSignalProperty(context)\n\n    this.options.behavior?.onFetch(\n      context as FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n      this as unknown as Query,\n    )\n\n    // Store state in case the current fetch needs to be reverted\n    this.#revertState = this.state\n\n    // Set to fetching state if not already in it\n    if (\n      this.state.fetchStatus === 'idle' ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.#dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    const onError = (error: TError | { silent?: boolean }) => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.#dispatch({\n          type: 'error',\n          error: error as TError,\n        })\n      }\n\n      if (!isCancelledError(error)) {\n        // Notify cache callback\n        this.#cache.config.onError?.(\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n        this.#cache.config.onSettled?.(\n          this.state.data,\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc()\n      }\n      this.isFetchingOptimistic = false\n    }\n\n    // Try to fetch the data\n    this.#retryer = createRetryer({\n      fn: context.fetchFn as () => Promise<TData>,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (data === undefined) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`,\n            )\n          }\n          onError(new Error(`${this.queryHash} data is undefined`) as any)\n          return\n        }\n\n        this.setData(data)\n\n        // Notify cache callback\n        this.#cache.config.onSuccess?.(data, this as Query<any, any, any, any>)\n        this.#cache.config.onSettled?.(\n          data,\n          this.state.error as any,\n          this as Query<any, any, any, any>,\n        )\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc()\n        }\n        this.isFetchingOptimistic = false\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.#dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.#dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n      canRun: () => true,\n    })\n\n    return this.#retryer.start()\n  }\n\n  #dispatch(action: Action<TData, TError>): void {\n    const reducer = (\n      state: QueryState<TData, TError>,\n    ): QueryState<TData, TError> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused',\n          }\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching',\n          }\n        case 'fetch':\n          return {\n            ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null,\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null,\n            }),\n          }\n        case 'error':\n          const error = action.error as unknown\n\n          if (isCancelledError(error) && error.revert && this.#revertState) {\n            return { ...this.#revertState, fetchStatus: 'idle' }\n          }\n\n          return {\n            ...state,\n            error: error as TError,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error as TError,\n            fetchStatus: 'idle',\n            status: 'error',\n          }\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true,\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate()\n      })\n\n      this.#cache.notify({ query: this, type: 'updated', action })\n    })\n  }\n}\n\nexport function fetchState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  data: TData | undefined,\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: canFetch(options.networkMode) ? 'fetching' : 'paused',\n    ...(data === undefined &&\n      ({\n        error: null,\n        status: 'pending',\n      } as const)),\n  } as const\n}\n\nfunction getDefaultState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): QueryState<TData, TError> {\n  const data =\n    typeof options.initialData === 'function'\n      ? (options.initialData as InitialDataFunction<TData>)()\n      : options.initialData\n\n  const hasData = data !== undefined\n\n  const initialDataUpdatedAt = hasData\n    ? typeof options.initialDataUpdatedAt === 'function'\n      ? (options.initialDataUpdatedAt as () => number | undefined)()\n      : options.initialDataUpdatedAt\n    : 0\n\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'pending',\n    fetchStatus: 'idle',\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}